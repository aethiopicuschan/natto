package nat

import (
	"encoding/binary"
)

type PacketKind uint8

const (
	PacketControl PacketKind = 1
	PacketData    PacketKind = 2
)

var (
	// Magic prefix for all packets generated by this library.
	packetMagic = [4]byte{'N', 'A', 'T', '1'}
)

// Packet is a framed UDP payload used by this library.
// Layout (big endian):
// [0..3]  magic "NAT1"
// [4]     kind (1=control, 2=data)
// [5..6]  payload length (uint16)
// [7..]   payload bytes
type Packet struct {
	Kind    PacketKind
	Payload []byte
}

func EncodePacket(kind PacketKind, payload []byte) (out []byte, err error) {
	if len(payload) > 0xFFFF {
		err = ErrMalformedPacket
		return
	}

	out = make([]byte, 7+len(payload))
	copy(out[0:4], packetMagic[:])
	out[4] = byte(kind)
	binary.BigEndian.PutUint16(out[5:7], uint16(len(payload)))
	copy(out[7:], payload)
	return
}

func DecodePacket(b []byte) (p *Packet, err error) {
	if len(b) < 7 {
		err = ErrMalformedPacket
		return
	}
	if b[0] != packetMagic[0] || b[1] != packetMagic[1] || b[2] != packetMagic[2] || b[3] != packetMagic[3] {
		err = ErrNotOurPacket
		return
	}

	kind := PacketKind(b[4])
	n := int(binary.BigEndian.Uint16(b[5:7]))
	if 7+n > len(b) {
		err = ErrMalformedPacket
		return
	}

	p = &Packet{
		Kind:    kind,
		Payload: b[7 : 7+n],
	}
	return
}
